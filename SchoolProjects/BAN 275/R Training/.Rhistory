muhat.vals = apply(returns.mat, 2, mean)
muhat.vals
sbux1 = log(sbux)
View(sbux1)
mean(sbux1)
mean(log(msft))
mean(log(sp500))
?lower.tri
mu = 0.05, sd = 0.10, n.obs = 100
mu = 0.05; sd = 0.10; n.obs = 100
mu = 0.05; sd = 0.10; n.obs = 100; n.sim = 1000; set.seed(111)
sim.means = rep(0, n.sim); sim.vars = rep(0, n.sim); sim.sds = rep(0, n.sim)
for (sim in 1:n.sim) {sim.ret = rnorm(n.obs, mean=mu, sd=sd)}
for (sim in 1:n.sim) {sim.ret = rnorm(n.obs, mean=mu, sd=sd),}
source('~/.active-rstudio-document', echo=TRUE)
?rep()
sim.means
sim.means[sim]
mean(sim.vars)
mu = 0.05; sd = 0.10; n.obs = 100; n.sim = 1000;
set.seed(111)
sim.means = rep(0, n.sim); sim.vars = rep(0, n.sim); sim.sds = rep(0, n.sim)
for (sim in 1:n.sim) {sim.ret = rnorm(n.obs, mean=mu, sd=sd),
}
for (sim in 1:n.sim) {sim.ret = rnorm(n.obs, mean=mu, sd=sd),
sim.means[sim] = mean(sim.ret),
sim.vars[sim] = var(sim.ret)
sim.sds[sim] = sqrt(sim.vars[sim])
}
for (sim in 1:n.sim) {sim.ret = rnorm(n.obs, mean=mu, sd=sd),
sim.means[sim] = mean(sim.ret),
sim.vars[sim] = var(sim.ret)
sim.sds[sim] = sqrt(sim.vars[sim])
}
for (sim in 1:n.sim) {sim.ret = rnorm(n.obs, mean=mu, sd=sd),
sim.means[sim] = mean(sim.ret),
sim.vars[sim] = var(sim.ret)
sim.sds[sim] = sqrt(sim.vars[sim])}
for (sim in 1:n.sim) {sim.ret = rnorm(n.obs, mean=mu, sd=sd),
for (sim in 1:n.sim) {sim.ret = rnorm(n.obs, mean=mu, sd=sd),
for (sim in 1:n.sim) {sim.ret = rnorm(n.obs, mean=mu, sd=sd)
sim.means[sim] = mean(sim.ret)
sim.sds[sim] = sqrt(sim.vars[sim])
}
summary(sim.means[sim])
plot(sim.means[sim])
str(sim.means[sim])
plot(sim)
plot(sim.means)
plot(sim.ret)
sd(sim.means)
sd
sim.means[1]
sim.means[2]
sim.means[999]
sim.means[1001]
sim.means[0]
summary(sim.means)
sim.means
mean(sim.ret)
mean(sim.ret)
sim.ret = rnorm(n.obs, mean = mu, sd = sd)
sim.ret
sim.ret = rnorm(n.obs, mean = mu, sd = sd)
sim.ret
mu.hat = mean(sim.ret)}
}
mu = 0.05; sd = 0.10; n.obs = 100; n.sim = 1000;
mu.lower = rep(0, n.sim); mu.upper = rep(0, n.sim)
for ( sim in 1:n.sim) {sim.tert = rnorm(n.obs, mean=mu, sd=sd)
mu.hat = mean(sim.ret)
se.muhat = sd(sim.ret)/sqrt(n.obs)
mu.lower[sim] = mu.hat - 2*se.muhat
mu.upper[sim] = mu.hat + 2*se.muhat
}
in.interval = (mu >= mu.lower) & (mu <= mu.upper)
sum(in.interval)/n.sim
in.interval
mu = 0.05; sd = 0.10; n.obs = 100; n.sim = 1000;
mu = 0.05; sd = 0.10; n.obs = 100; n.sim = 1000;
set.seed(111)
mu.lower = rep(0, n.sim); mu.upper = rep(0, n.sim)
for ( sim in 1:n.sim) {sim.tert = rnorm(n.obs, mean=mu, sd=sd)
mu.hat = mean(sim.ret)
se.muhat = sd(sim.ret)/sqrt(n.obs)
mu.lower[sim] = mu.hat - 2*se.muhat
mu.upper[sim] = mu.hat + 2*se.muhat
}
in.interval = (mu >= mu.lower) & (mu <= mu.upper)
sum(in.interval)/n.sim
sum(in.interval)/n.sim
hist(sim.means)
hist(sim.vars)
hist(sim.means[sim])
hist(sim.sds)
?hist()
hist(sim.sds, freq = NULL)
?hist()
hist(sim.sds, xlim = 0.1)
?hist()
hist(sim.sds, xlim = range(0.1)
)
hist(sim.means, xlim = range(0.1)
)
?hist()
bsc <- function(S,T,t,K,r,s,q) {
d1 <- (log(S/K)+(r-q+0.5*s^2)*(T-t)/(s*sqrt(T-t))
d2 <- d1-s*sqrt(T-t)
S*exp(-q*(T-t))*pnorm(d1)-K*exp(-r*(T-t))*pnorm(d2)
}
bsc <- function(S,T,t,K,r,s,q) {
d1 <- (log(S/K)+(r-q+0.5*s^2)*(T-t)/(s*sqrt(T-t))
d2 <- d1-s*sqrt(T-t)
help bsc
bsc
clear
clc
bsc <- function(S,T,t,K,r,s,q) {
d1 <- (log(S/K)+(r-q+0.5*s^2)*(T-t))/(s*sqrt(T-t))
d2 <- d1-s*sqrt(T-t)
S*exp(-q*(T-t))*pnorm(d1)-K*exp(-r*(T-t))*pnorm(d2)
}
bsc
bsc(50,0.5,0.0,45,0.06,0.2,0.02)
bsc <- function(S,T,t,K,r,s,q) {
d1 <- (log(S/K)+(r-q+0.5*s^2)*(T-t))/(s*sqrt(T-t))
d2 <- d1-s*sqrt(T-t)
S*exp(-q*(T-t))*pnorm(d1)-K*exp(-r*(T-t))*pnorm(d2)
}
bsc(50,0.5,0.0,45,0.06,0.2,0.02)
bsc(50,0.5,0.0,45,0.06,0.2,0.02)
bsc(50,0.5,0.0,45,0.06,0.2,0.02)
bsc <- function(S,T,t,K,r,s,q) {
d1 <- (log(S/K)+(r-q+0.5*s^2)*(T-t))/(s*sqrt(T-t))
d2 <- d1-s*sqrt(T-t)
S*exp(-q*(T-t))*pnorm(d1)-K*exp(-r*(T-t))*pnorm(d2)
}
bsc <- function(S,T,t,K,r,s,q) {
d1 <- (log(S/K)+(r-q+0.5*s^2)*(T-t))/(s*sqrt(T-t))
d2 <- d1-s*sqrt(T-t)
S*exp(-q*(T-t))*pnorm(d1)-K*exp(-r*(T-t))*pnorm(d2)
}
bsc <- function(S,T,t,K,r,s,q) {
d1 <- (log(S/K)+(r-q+0.5*s^2)*(T-t))/(s*sqrt(T-t))
d2 <- d1-s*sqrt(T-t)
S*exp(-q*(T-t))*pnorm(d1)-K*exp(-r*(T-t))*pnorm(d2)
}
bsc <- function(S,T,t,K,r,s,q) {
d1 <- (log(S/K)+(r-q+0.5*s^2)*(T-t))/(s*sqrt(T-t))
d2 <- d1-s*sqrt(T-t)
S*exp(-q*(T-t))*pnorm(d1)-K*exp(-r*(T-t))*pnorm(d2)
}
seq()
f
f
f
a
bsc <- function(S,T,t,K,r,s,q) {
rep(1,2)
rep(x[n+1],2)
x[n+1]
View(iris)
x[n+1]
mean[15,9,6,12]
?rnorm
help.search('rnorm')
con <- url("http://www.jhsph.edu","r")
con
readlines(con)
readLines(con)
x <- readLines(con)
head(x)
con <- url("http://www.jhsph.edu","r")
x <- readLines(con)
clc
clear
lapply
rm(list=ls())
add2 <- function(x, y) {
x + y
}
add2(2,3)
above <- function(x, n) {
use <- x > n
x[use]
}
above(2,10)
above(11,10)
ncol(1:20)
ncol
help("ncol")
help("numeric")
numeric(2)
x <- matrix(1:6,row=2,col=3)
x <- matrix(1:6,nrow=2,ncol=3)
x
mean(x)
mean(x,1)
mean(x,2)
help(mean)
colMeans(x)
rowMeans(x)
install.packages("rhadoop")
install.packages("RHive")
install.packages("ColByCol")
install.package(ColByCol)
install.package('ColByCol')
install.package('ColByCol R package')
packageName(env = parent.frame())
install.packages(c("boot", "codetools", "foreign", "manipulate", "MASS", "Matrix", "mgcv", "nlme"))
.libPaths()
rm(list=ls())
## Two utility functions to cache and compute/retrieve the inverse of a matrix
##
## makeCacheMatrix
## This function creates a special "matrix" object that can cache its inverse.
##
## cacheSolve
## This function computes/retrieves the inverse of the special "matrix"
## returned by the function makeCacheMatrix.
## If the inverse has already been calculated (and the matrix has not changed),
## then cacheSolve should retrieve the inverse from the cache.
## makeCacheMatrix()
## set - sets the value of the matrix
## get - gets the value of the matrix
## setinv - sets the inverse of the matrix
## getinv - gets the inverse of the matrix
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinv <- function(solve) m <<- solve
getinv <- function() m
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## cacheSolve(x, ...)
## Checks for a cached inverse matrix or compute one if not already cached
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinv()
if(!is.null(m)) {
message("getting cached matrix")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinv(m)
m
}
myMat <- matrix(1:6,nrow=3,ncol=2)
myMat
makeCacheMatrix(myMat)
cacheSolve(myMat)
tmp <- makeCacheMatrix(myMat)
cacheSolve(tmp)
myMat <- matrix(1:9)
myMat
myMat <- matrix(1:9, nrow=3, ncol=3)
myMat
myMat <- matrix(rnorm(9),nrow=3,ncol=3)
myMat
tmp <- makeCacheMatrix(myMat)
cacheSolve(tmp)
# These functions cache the time-consuming operation of
# caluclating the inverse of a matrix.
# This function creates a special "matrix" object that
# can cache it's inverse.
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
#set will calculate the matrix
set <- function(y) {
x <<- y
inverse <<- NULL
}
#get will return the existing matrix
get <- function() x
setinverse <- function(inverse) inverse <<- inverse
getinverse <- function() inverse
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## This function computes the inverse of the special
## matrix above. If the cache has already been caclulated
## and has not changed, then this function should retrieve
## the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)){
return(inverse)
}
#get the solved matrix
data <- x$get()
inverse <- solve(data, ...)
#set using the object created by the other function
x$setinverse(inverse)
return(inverse)
}
tmp <- makeCacheMatrix(myMat)
cacheSolve(tmp)
# This function creates a special "matrix" object
# that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
## define the cache m and inizialize with NULL value
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setInverse <- function(inverse) m <<- inverse
getInverse <- function() m
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# This function computes the inverse of the special
# "matrix" returned by `makeCacheMatrix` above. If the inverse has
# already been calculated (and the matrix has not changed), then
# `cacheSolve` should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getInverse()
if(!is.null(m)) {
message("Getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setInverse(m)
m
}
# This function creates a special "matrix" object
# that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
## define the cache m and inizialize with NULL value
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setInverse <- function(inverse) m <<- inverse
getInverse <- function() m
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# This function computes the inverse of the special
# "matrix" returned by `makeCacheMatrix` above. If the inverse has
# already been calculated (and the matrix has not changed), then
# `cacheSolve` should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getInverse()
if(!is.null(m)) {
message("Getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setInverse(m)
m
}
tmp <- makeCacheMatrix(myMat)
tmp
cacheSolve(tmp)
install.package(swirl)
install.package.(swirl)
install.packages("swirl")
library(swirl)
swirl()
?sample
sample(1:6,4,replace=TRUE)
sample
info()
sample(1:6, 4, replace = TRUE)
sample(1:20,10)
sample(1:20,10)
LETTERS
sample(LETTERS)
sample(c(0,1),100,replacement=TRUE,prob=c(0.3,0.7))
sample(c(0,1),100,replace=TRUE,prob=c(0.3,0.7))
flips <- sample(c(0,1),100,replace=TRUE,prob=c(0.3,0.7))
flips
sum(flips)
?rbinom
rbinom(1, size = 100,
| prob = 0.7)
rbinom(1, size = 100,prob = 0.7)
flips2<-rbinom(1,size=1,prob=0.7)
flips2<-rbinom(100,size=1,prob=0.7)
flips2
sum(flips)
sum(flips2)
rnorm
?rnorm
rnorm(10)
rnorm(10,100,25)
rpois(5,10)
replicat(100,rpois(5,10\))
replicat(100,rpois(5,10\)
replicat(100,rpois(5,10)
)
replicate(100,rpois(5,10))
my_pois <- replicate(100, rpois(5, 10))
my_pois
colMeans(my_pois)
cm <- colMeans(my_pois)
hist(cm)
View(flags)
sapply(flags, unique)
ok()
sapply(flags, class)sapply(flags, class)
sapply(flags, class)
vapply(flags,
| class, character(1))
vapply(flagsclass, character(1))
vapply(flags,class, character(1))
?
?tapply
?tapply
table(flags$landmass)
table(flags$animate)
tapply(flags$animate, flags$landmass, mean)
View(flags)
save.image("~/Untitled.RData")
tapply(flags$population, flags$red, summary)
tapply(flags$population, flags$landmass, summary)
ls()
class(plants)
dim(plants)
nrow(plants)
ncol(plants)
object.size(plants)
names(plants)
head(plants)
head(plants,10)
tail(plants,15)
summary(plants)
table(plants$Active_Growth_Period)
str()
str(plants)
data(cars)
?cars
head(cars)
plot(cars)
?plot
plot(x = cars$speed, y = cars$dist)
plot(y = cars$speed, x = cars$dist)
plot(y = cars$speed, x = cars$dist)
plot(x = cars$speed, y = cars$dist, xlab = "Speed")
plot(x = cars$speed, y = cars$dist, ylab = "Stopping Distance")
plot(x = cars$speed, y = cars$dist, ylab = "Stopping Distance". xlab = )
plot(x = cars$speed, y = cars$dist, ylab = "Stopping Distance". xlab = "Spped")
plot(x = cars$speed, y = cars$dist, ylab = "Stopping Distance". xlab = "Speed")
plot(x = cars$speed, y = cars$dist, ylab = "Stopping Distance", xlab = "Speed")
plot(x = cars$speed, y = cars$dist, ylab = "Stopping Distance", xlab = "Speed")
plot(x = cars$speed, y = cars$dist, ylab = "Stopping Distance", xlab = "Speed", ,ain = "My Plot")
plot(x = cars$speed, y = cars$dist, ylab = "Stopping Distance", xlab = "Speed", ,main = "My Plot")
warnings()
plot(x = cars$speed, y = cars$dist, ylab = "Stopping Distance", xlab = "Speed",main = "My Plot")
plot(cars, ylab = "Stopping Distance", xlab = "Speed",main = "My Plot")
plot(cars,main = "My Plot")
plot(cars,main = "My Plot", sub=)
plot(cars,main = "My Plot", sub="My Plot Subtitle")
plot(cars,sub="My Plot Subtitle")
plot(cars,col=2)
plot(cars,col=2,xlim=c(10,15))
plot(cars,xlim=c(10,15))
plot(cars,pch=2)
data(mtcars)
?boxplot
boxplot(mpg~cyl)
boxplot(mpg~cyl,mtcars)
hist(mtcars$mpg)
swirl()
install.packages('configure')
install.packages('rgeos', type='source')
install.packages('configure', type='source')
library("boot", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
install.packages('configure', type='source')
install.packages('RQuantLib')
install.packages('RQuantLib',type='source')
library('RQuantLib')
install.packages('configure', type='source')
install.packages('configure', type='source')
install.packages('RQuantLib',type='source')
install.packages('QuantLib',type='source')
install.packages('QuantLib',type='source')
install.packages('configure', type='source')
install.packages('RQuantLib',type='source')
install.packages("~/Downloads/QuantLib-1.4.1.tar", repos = NULL)
getwd
setwd(/R Training)
setwd('/R Training')
getwd()
setwd("/Users/gabrielfeng/Documents/R directory/R Training")
load("/Data Types/Data Types.RData")
load("~/Data Types/Data Types.RData")
load("~/Users/gabrielfeng/Documents/R directory/R Training/Data Types/Data Types.RData")
library("xts", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
source('~/.active-rstudio-document', echo=TRUE)
library("RUnit", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
library("rgl", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
install.packages('RQuantLib',type='source')
configuration
install.packages('configure', type='source')
version
R --version
